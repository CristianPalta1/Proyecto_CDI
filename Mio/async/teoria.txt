JavScript es sincrono y no bloqueante con un bucle de eventos(concurrencia)
Implementado con u unico hilo para sus interfaces de entrada y salida


Single-threaded: AUn con multiples procesadores solo se puede ejecutar tareas en un solo hilo, 
El hilo principal

Bloqueante: una tarea no devuelve el control hasta que se ha completado. El alert es un ejemplo

No bloquente: UNa tarea devuelve el resultado para que el codigo siga


EventLoop es un bucle de eventos es un patyron de dise√±o que es√©ra y distibuye eventos o mensajes
en un programa

Event Loop: Es un bucle de eventos que distribuye eventos o mensajes en el programa. Ademas de 
movert del task Queue al Call Stack solo si este esta vac√≠o.

    memory heap: los objetos variables  son asignados a una memoria para luego ser usados

    call stack: aplia de forma organizada las instrucciones de nuestro porgrama. Hay que tener en cuenta
    LIFO (Last-in, First-out). 

    Task queue: cola de tareas, se agregan las tareas que ya estan listas para el stack


üì≤ XMLHttpRequest es un objeto de JS que permite hacer peticiones hacia servicios en la nube(URLs o APIs).
.
üì™ Existen 5 estados en un llamado XMLHttpRequest:
.

0 ‚Üí Se ha inicializado.
1 ‚Üí Loading (cargando).
2 ‚Üí Se ha cargado.
3 ‚Üí Procesamiento si existe alguna descarga.
4 ‚Üí Completado.
.
üì´ M√©todos y propiedades:
.
xmlhttp.open() ‚Üí Prepara la petici√≥n para ser enviada tomando tres par√°metros: pr√≥tocolo, url, as√≠ncrono (true).
xmlhttp.readyState ‚Üí Retorna el estado de la petici√≥n.
xmlhttp.onreadystatechange ‚Üí Un eventHandler que es llamado cuando la propiedad readyState cambia.
xmlhttp.status ‚Üí Retorna el estado de la respuesta de la petici√≥n. (200,400,500)
xmlhttp.send() ‚Üí Env√≠a la petici√≥n.
.
üì¨ Caracter√≠sticas del protocolo http:
.
Verbos: Los verbos indican acciones que est√°n asociadas a peticiones y recursos, es decir, sirven para la manipulaci√≥n de recursos cliente/servidor. Los Verbos http son:

GET ‚Üí Solicita un recurso.
HEAD ‚Üí Solicita un recurso pero sin retornar informaci√≥n, la estructura de esta petici√≥n es igual que get tanto en su headers como estatus. Es √∫til cuando vamos a utilizar API, para comprobar si lo que vamos a enviar esta correcto y puede ser procesado.
POST ‚Üí Sirve para la creaci√≥n de recursos en el servidor.
PUT ‚Üí Actualiza por completo un recurso, reemplaza todas las representaciones actuales del recurso de destino con la carga √∫til de la petici√≥n.
PATCH ‚Üí Actualiza parcialmente un recurso.
DELETE ‚Üí Elimina un recurso.
.
üì≠ Los c√≥digos de estados del servidor:
.
El c√≥digo de estado (status codes) sirve para describir el estado de la petici√≥n hecha al servidor.

1xx ‚Üí Indican que la petici√≥n fue recibida por el servidor, pero est√° siendo procesada por el servidor.
2xx ‚Üí Indican que la petici√≥n fue recibida, aceptada y procesada correctamente.
3xx ‚Üí Indican que hay que tomar acciones adicionales para completar la solicitud.
4xx ‚Üí Indican errores del lado del cliente que hizo mal una solicitud.
5xx ‚Üí Indican errores del servidor. Suelen aparecer cuando existe un fallo en la ejecuci√≥n en el servidor.
.
üìß Los c√≥digos m√°s comunes a la hora de interactuar con una API son:
.

200 ‚Üí OK ‚Üí Indica que todo est√° correcto.
201 ‚Üí Created ‚Üí Todo est√° correcto cuando se hizo una solicitud POST, el recurso se cre√≥ y se guard√≥ correctamente.
204 ‚Üí No Content ‚Üí Indica que la solicitud se complet√≥ correctamente pero no devolvi√≥ informaci√≥n. Este es com√∫n cuando se hacen peticiones con el verbo DELETE.
400 ‚Üí Bad Request ‚Üí Indica que algo est√° mal en la petici√≥n (no encontr√≥ algo).
401 ‚Üí Unauthorized ‚Üí Significa que antes de hacer una solicitud al servidor nos debemos autenticar.
403 ‚Üí Forbidden ‚Üí Indica que no tenemos acceso a ese recurso aunque se est√© autenticado.
404 ‚Üí Not Found ‚Üí Indica que no existe el recurso que se est√° intentando acceder.
500 ‚Üí Internal Server Error ‚Üí Indica que algo fall√≥, es un error que retorna el servidor cuando la solicitud no pudo ser procesada.

Un callback devuelve una funci√≥n en los par√°metros, cuando llamamos varias veces un callback, estaremos colocando muchas lineas de c√≥digo y ser√≠a engorroso, por eso nacen las promesas, √©stas optimizan y permiten leer mejor el c√≥digo con pocas lineas.
.
ü´±üèº‚Äçü´≤üèæ Las promesas son as√≠ncronas, por lo que el c√≥digo continuar√° su ejecuci√≥n normalmente y luego dir√° si la promesa se resolvi√≥ o se rechaz√≥. Por lo que varias promesas pueden llegar a entrar en ejecuci√≥n al mismo tiempo.
.
Las promesas pueden suceder:
.

Ahora
En el futuro
Nunca
.
üõ†Ô∏è Para crear una promesa:
.
Utilizamos la palabra reservada new seguida de la palabra Promise que es el constructor de la promesa. Este constructor recibe un √∫nico par√°metro que es una funci√≥n, la cu√°l a su vez, recibe otros dos par√°metros: resolve y reject.

El par√°metro resolve se utiliza para cuando la promesa devuelve el valor correctamente.
El par√°metro reject, se usa en el que caso de que no funcione.

Una Promesa puede estar en uno de los siguientes estados:
.

Pendiente pending ‚Üí Una promesa inicia en este estado: no cumplida, no rechazada:
Una promesa inicialmente est√° pendiente.
Cumplida fulfilled ‚Üí Significa que la operaci√≥n se complet√≥ satisfactoriamente, .then(va => ‚Ä¶)
Cuando llamamos a resolve entonces la promesa pasa a estar resuelta.
Cuando una promesa se resuelve entonces se ejecuta la funci√≥n que pasamos al m√©todo .then
Rechazada rejected ‚Üí significa que la operaci√≥n fall√≥, .catch(err => ‚Ä¶)
Si llamamos a reject pasa a estar rechazada (obtenemos un error que nos va a indicar la raz√≥n del rechazo).
Si la promesa es rechazada entonces se ejecuta la funci√≥n que pasamos a .catch



Fetch solo sirve renderizando la logica del JS en en navegador. SI se quiere usar con node se debe instalar la dependevia node-Fetch


üîÅ ¬øQu√© es una funci√≥n as√≠ncrona?
.
La declaraci√≥n de funci√≥n async define una funci√≥n as√≠ncrona que devuelve un objeto, lo cual permite a un programa correr una funci√≥n sin congelar todo la compilaci√≥n.
Dada que la finalidad de las funciones async/await es simplificar el comportamiento del uso s√≠ncrono de promesas, se hace m√°s f√°cil escribir promesas.
.
üîè La estructura se compone por las palabras reservadas async y await:
.

La palabra async antes de la funci√≥n, hace que la funci√≥n devuelva una promesa.
La palabra await se utiliza dentro de las funciones async, lo que hace que el programa espere hasta que la variable(promesa) se resuelva para continuar.
.
‚úèÔ∏è Ejemplo con c√≥digo:
.

Ir a VSC, crear dentro de la carpeta src una carpeta llamada async.
En la ruta src/async crear el archivo index.js
Dentro del archivo index.js, se crea la promesa y luego se valida si la promesa se resolver√°, tambi√©n se hace el llamado de la misma y luego se busca mostrar como se desenvuelve con await. En el ejemplo se usa el if ternario.
.

üö• ¬øQu√© es un operador if ternario?
.
El operador ternario consta de 3 partes: condici√≥n ? expresi√≥n1 : expresi√≥n2;

La primera es la l√≥gica, se eval√∫a una condici√≥n.
La segunda parte est√° despu√©s del signo de cierre de interrogaci√≥n ?, √©sta se ejecuta solo si la condici√≥n es verdadera true.
La tercera parte est√° despu√©s del s√≠mbolo de dos puntos :, √©sta se ejecuta solo si la condici√≥n resulta falsa false.

En √©sta clase vamos a implementar lo aprendido de async/await usando la API y una nueva estructura con try/catch.
.
üö® Importante recordar que la estructura de async/await se compone por las palabras reservadas async y await:
.

La palabra async se coloca antes de la funci√≥n (la otra forma es con funciones flecha en que el async va antes que los argumentos).
La palabra await se utiliza dentro de las funciones async.
.
üñáÔ∏è Otra forma de hacer que async/await espere a varios llamados a la vez es con la estructura: Try /Catch:
.

La palabra reservada try consiste en un bloque que contiene una o m√°s sentencias, como hac√≠amos con resolve.
Su cuerpo est√° conformado por las llaves {} las cuales se deben utilizar siempre, incluso para un bloque de una sola sentencia.
Tambi√©n puede estar presente un bloque con la palabra reservada catch.
Un bloque catch es opcional (como hac√≠amos con reject) y contiene sentencias que especifican que hacer si una excepci√≥n es lanzada en el bloque try.
Si no se lanza ninguna excepci√≥n en el bloque try, el bloque catch se omite.


.
Un generador en JavaScript consta de una funci√≥n generadora que muestra un objeto iterable Generator. La palabra reservada yield se usa para pausar y reanudar una funci√≥n generadora.
Fuente: aqu√≠
.

La estructura del Generador consta con la palabra function seguido de un aster√≠sco * : function* √©sta es una funci√≥n generadora heredada.
El resultado que se quiere obtener se coloca al lado derecho de yield, puede ser de cualquier tipo (string, num√©rico, objetos, etc) y se puede tener tantos yield que se desee.